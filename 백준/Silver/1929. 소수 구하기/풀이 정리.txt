'에라토스테네스의 체'라는 소수 구하기 개념을 활용해 푸는 문제
수학 개념은 이해를 했지만, 코드 상으로 구현했을 때 런타임 에러 때문에 매우 골치 아팠던 문제였다😵‍💫

● 에라토스테네스의 체
주어진 수 이하의 소수를 구하고자 할 때,
주어진 수의 제곱근(루트 값) 보다 작은 수의 배수를 제거해 빠르게 소수를 구하는 방법이다.

1은 소수가 아니다
제곱근 이하의 정수의 배수는 소수가 아니다
자기 자신과 1로만 나누어 떨어지는 수가 소수이다

예) 주어진 수: 23
    23의 제곱근: 4.79583152331
    
    1을 제외하고 2, 3, 4의 배수 제거
    2의 배수: 4, 6, 8, 9, 10, 12, 14, 16, 18, 20, 22
    3의 배수: 9, 15, 21 (2의 배수에서 제거된 수는 포함하지 않는다)
    4의 배수는 2의 배수에서 이미 제거되었으므로 굳이 비교할 필요가 없다

23 이하의 소수: 2, 3, 5, 7, 11, 13, 17, 19, 23

=============================================================================================================
# n의 제곱근을 구하는 코드
import math
sqrt_num = int(math.sqrt(n))

# m 이상이고 n 이하인 수와 길이가 동일한 bool 리스트로 소수인지 아닌지 판별
numbers = [_ for _ in range(m, n+1)]
prime_judge = [True] * len(numbers)

# 2부터 제곱근까지의 배수 비교를 위해 반복
for mul in range(2, sqrt_num+1):
  for num in range(mul*mul, n+1, mul):  # 소수 제거에 자기 자신을 포함하면 안되므로 소수*소수로 배수부터 시작
    if num >= m:  # 판별하려는 수가 범위에 없으면 안됨(Index Error 발생) (예: 5부터 범위인데 2*2=4는 비교할 수 없음)
      prime_judge[num - m] = False  # 숫자 리스트와 길이만 맞추고 인덱스는 일치시키지 않았으므로 시작 범위만큼 빼줌

if numbers[0] == 1:
  prime_judge[0] = False  # 1이 포함되어 있을 때(범위가 1부터 시작이라면) 1은 소수가 아니라고 판단

for idx in range(len(numbers)):
  if prime_judge[idx]:  # 소수(True 값)이면 출력
        print(numbers[idx])
=============================================================================================================
